import numpy as np
import tensorflow as tf
from evaluation.shared import log10

def prepare_sharpdiff(inputs_flat_shape):
    def sharpdiff(inputs, x_logits):
        """
        Computes the Sharpness Difference error between the generated images and the ground truth
        images.

        @param gen_frames: A tensor of shape [batch_size, height, width, 3]. The frames generated by the
                           generator model.
        @param gt_frames: A tensor of shape [batch_size, height, width, 3]. The ground-truth frames for
                          each frame in gen_frames.

        @return: A scalar tensor. The Sharpness Difference error over each frame in the batch.
        """
        imageB = tf.sigmoid(x_logits)
        imageA = inputs
        imageB = tf.reshape(imageB, tf.TensorShape(inputs_flat_shape))
        imageA = tf.reshape(imageA, tf.TensorShape(inputs_flat_shape))

        num_pixels = tf.cast(x=inputs_flat_shape[1] * inputs_flat_shape[2] * inputs_flat_shape[3], dtype='float')
        if inputs_flat_shape[3] == 1:
            imageB = tf.image.grayscale_to_rgb(imageB)
            imageA = tf.image.grayscale_to_rgb(imageA)

            shapeB = tf.shape(imageB)
            num_pixels = tf.cast(x=shapeB[1] * shapeB[2] * shapeB[3], dtype='float')

        # gradient difference
        # create filters [-1, 1] and [[1],[-1]] for diffing to the left and down respectively.
        # Could this be simplified with one filter [[-1, 2], [0, -1]]?
        pos = tf.constant(np.identity(3), dtype=tf.float32)
        neg = -1 * pos
        filter_x = tf.expand_dims(tf.stack([neg, pos]), 0)  # [-1, 1]
        filter_y = tf.stack([tf.expand_dims(pos, 0), tf.expand_dims(neg, 0)])  # [[1],[-1]]
        strides = [1, 1, 1, 1]  # stride of (1, 1)
        padding = 'SAME'

        gen_dx = tf.abs(tf.nn.conv2d(imageB, filter_x, strides, padding=padding))
        gen_dy = tf.abs(tf.nn.conv2d(imageB, filter_y, strides, padding=padding))
        gt_dx = tf.abs(tf.nn.conv2d(imageA, filter_x, strides, padding=padding))
        gt_dy = tf.abs(tf.nn.conv2d(imageA, filter_y, strides, padding=padding))

        gen_grad_sum = gen_dx + gen_dy
        gt_grad_sum = gt_dx + gt_dy

        grad_diff = tf.abs(gt_grad_sum - gen_grad_sum)

        batch_errors = 10 * log10(1 / ((1 / num_pixels) * tf.reduce_sum(grad_diff, [1, 2, 3])))
        return tf.reduce_mean(batch_errors)

    return sharpdiff